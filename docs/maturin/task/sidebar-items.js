initSidebarItems({"enum":[["TaskStatus","任务执行状态"]],"fn":[["exec_new_task","通过 exec 系统调用，直接切换到新的用户进程"],["exit_current_task","终止当前用户程序，回到 idle 状态"],["fetch_task_from_scheduler","从任务队列中拿一个任务，返回其TCB。 非阻塞，即如果没有任务可取，则直接返回 None"],["get_current_task","获取当前核正在运行的进程的TCB。 如果当前核没有任务，则返回 None"],["handle_signals","处理当前线程的信号"],["handle_user_page_fault","处理用户程序的缺页异常"],["push_task_to_scheduler","向任务队列里插入一个任务"],["run_tasks","开始执行用户程序"],["signal_return","从信号处理中返回。 为了适配 syscall，返回原来的用户上下文中的 a0 的值"],["suspend_current_task","暂停当前用户程序，回到 idle 状态"],["timer_kernel_to_user","从内核态进入用户态时统计时间"],["timer_user_to_kernel","从用户态进入内核态时统计时间"]],"mod":[["clone_flags","clone 任务时指定的参数。 这些参数使得 linux 的“线程“和“任务“更加灵活，可以选择共享或不共享某些信息"],["context","保存/恢复一个用户栈所必要的信息"],["cpu_local","每个核当前正在运行的任务及上下文信息"],["kernel_stack","内核栈 内部保存了 Frame，所以栈本身占用的内存会在结构被 Drop 时释放掉"],["scheduler",""],["switch","关于切换执行流的汇编 `__switch`"],["task","用户程序的数据及状态信息 一个 TaskControlBlock 包含了一个任务(或进程)的所有信息"],["time_stat","统计进程的用户态和内核态时间"]],"struct":[["CloneFlags","用于 sys_clone 的选项"],["ITimerVal","sys_gettimer / sys_settimer 指定的类型，用户输入输出计时器"],["KernelStack","内核栈，会通过帧分配器申请一段内存 在内核态时，这段内存是在 physical memory 上的，因此可以直接访问 这省去了修改 MemorySet 和页表的步骤，比较快，但也意味着没有 shadow page，需要由其他机制实现(Todo: trap.S 中判断) 因为 physical memory 中的所有页都有 READ/WRITE 权限"],["ORIGIN_USER_PROC","第一个用户程序 任务调度器启动时会自动在队列中插入它作为第一个用户程序"],["Scheduler","任务调度器，目前采用 Round-Robin 算法 在 struct 外部会加一个 Mutex 锁"],["TaskContext","一个任务的上下文信息，包含所有必要的寄存器"],["TaskControlBlock","任务控制块，包含一个用户程序的所有状态信息，但不包括与调度有关的信息。 默认在TCB的外层对其的访问不会冲突，所以外部没有用锁保护，内部的 mutex 仅用来提供可变性"],["TaskControlBlockInner","任务控制块的可变部分"],["TimeStat","进程的时间统计，基于 lmbench 需要，主要用于 sys_getrusage"]]});