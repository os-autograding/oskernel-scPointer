initSidebarItems({"fn":[["get_dir_from_fd","从一个表示目录的文件描述符中获取目录名。 如果这个文件描述符不是代表目录，则返回None"],["resolve_path_from_fd","从输入的路径文件描述符和文件名，解析实际的父目录和文件名。 成功时返回 0，失败时返回 -1"],["sys_access",""],["sys_chdir","切换当前工作路径，如果以.开头，默认是相对路径；如果以/开头，默认是绝对路径。切换成功时返回0，失败时返回-1"],["sys_close","关闭文件，成功时返回 0，失败时返回 -1"],["sys_dup","复制一个 fd 中的文件到一个新 fd 中，成功时返回新的文件描述符，失败则返回 -1"],["sys_dup3","复制一个 fd 中的文件到指定的新 fd 中，成功时返回新的文件描述符，失败则返回 -1"],["sys_fcntl64","设置文件属性。目前支持的比较少"],["sys_fstat","获取文件状态信息"],["sys_fstatat","获取文件状态信息，但是给出的是目录 fd 和相对路径。"],["sys_getcwd","获取当前工作路径"],["sys_getdents64","获取目录项信息"],["sys_ioctl","一些规则很混乱的 io 控制"],["sys_linkat","创建硬链接。成功时返回0，失败时返回-1"],["sys_lseek","修改文件指针位置"],["sys_mkdir","创建目录，成功时返回 0，失败时返回 -1"],["sys_mount","挂载文件系统。成功时返回0，失败时返回-1。"],["sys_open","打开文件，返回对应的 fd。如打开失败，则返回 -1"],["sys_pipe","创建管道，在 *pipe 记录读管道的 fd，在 *(pipe+1) 记录写管道的 fd。 成功时返回 0，失败则返回 -1"],["sys_pread","在 offset 位置读 count 个字符。这个文件必须支持 seek"],["sys_read","从 fd 代表的文件中读一个字串，最长为 len，放入 buf 中"],["sys_readlinkat","读取 (dir_fd, path) 所指向的字符串的符号链接的信息，并放入 buf 中，返回读取到的字符数。 存入的时候不会在结尾加入 ‘\\0’，也就是说如果需要读取的内容超过 len 的限制，则会直接截断并返回 len。"],["sys_readv","从同一个 fd 中读取一组字符串。 目前这个 syscall 借用 sys_read 来实现"],["sys_renameat2","重命名文件，也可以作为 move 使用。 目前只支持实际 FAT32 中做 move，其他的文件类型(如vfs)不支持，它们与 FAT32 之间的 move 也不支持。"],["sys_sendfile64","从 in_fd 读取最多 count 个字符，存到 out_fd 中。"],["sys_statfs","获取文件系统的信息"],["sys_umask","设置创建文件时 user_mode 的掩码，并返回原来的掩码。 对整个进程有效"],["sys_umount","卸载文件系统。成功时返回0，失败时(目录不存在/未挂载等)返回-1。"],["sys_unlinkat","删除硬链接，并在链接数为0时实际删除文件。成功时返回0，失败时返回-1"],["sys_utimensat","修改文件的访问时间和/或修改时间。"],["sys_write","写一个字串到 fd 代表的文件。这个串放在 buf 中，长为 len"],["sys_writev","写入一组字符串到同一个 fd 中。 目前这个 syscall 借用 sys_write 来实现"]]});