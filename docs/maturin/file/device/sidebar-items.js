initSidebarItems({"fn":[["add_link_for_all_files_in_dir","把 origin_dir 目录下的每个文件，链接到 link_dir 目录下的对应文件。 两个目录的结尾都需要有 ‘/’"],["check_dir_exists","检查目录是否存在 要求 dir_name 使用 os 中的格式，即以 “./” 开头"],["check_file_exists","检查文件是否存在。（不考虑link） 如果目录本身不存在，那么也会返回 false，不会报错。"],["fs_init","初始化硬盘内容。 由于它需要调用 MEMORY_FS，所以不能塞进其它初始化过程里"],["get_dir_entry_iter","获取一个迭代器，每次返回一个目录中的 DirEntry。如果对应目录不存在，返回 None"],["inner_open_dir","打开目录。如果是根目录，特判直接返回 root；否则打开代表目录的 FsDir"],["list_files_at_root","输出根目录下的所有文件"],["map_path_and_file","分割文件所在路径，然后经过link转换。"],["mkdir","创建目录，返回是否成功"],["open_file","在 dir_name 目录下，打开 name 文件。 如果不包含 OpenFlags::DIR，可能出现如下情况："],["parse_dir","在 path 后加入 child_path 路径，返回 child_path 中最后一个 ‘/’ 的位置+1。(如没有 ‘/’ 则返回0) 注意根路径的父路径视为自己。"],["remove_file","删除文件"],["rename_or_move","移动文件，如果 new_dir == old_dir 则表现为重命名 只检查 FAT32，不考虑 vfs。不考虑符号链接，因为实现是在 fs 里实现的，而链接在内核里"],["split_path_and_file","分割文件所在路径。返回的第一个值是路径，它是新生成的String，复制了需要的字符；第二个值是 slice，指向 file_path 的一部分。"]],"mod":[["fat_dir","FAT中的目录抽象。 主要是包装实现 Trait File"],["fat_file","FAT中的文件抽象。"],["fd_dir","以文件描述符形式保存一个路径。 主要用于 sys_openat ，这个系统调用需要文件所在目录的 fd"],["link","处理文件系统的链接相关"],["open_flags","打开文件时的权限和选项"],["stat","整个文件系统的信息"],["test","运行比赛测试"]],"struct":[["MEMORY_FS",""]],"type":[["FATFileSystem",""],["FsDir",""],["FsDirIter",""],["FsFile",""],["FsIO",""],["FsOCC",""],["FsTP",""]]});