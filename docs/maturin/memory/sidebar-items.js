initSidebarItems({"enum":[["CutSet","当前 VmArea 和另一个给定的需要 mprotect 的区间的相交关系 这里仅考虑区间已经相交的情况，如果不确认是否相交，需要先调用 VmArea::is_overlap_with"],["DiffSet","当前 VmArea 和另一个给定的需要 unmap 的区间的相交关系"]],"fn":[["allocator_init","初始化堆分配器、页帧分配器和 TID 分配器。需由其中一个核调用且仅调用一次"],["create_mapping",""],["enable_kernel_page_table","切换到 KERNEL_MEMORY_SET 中的页表。 每个核启动时都需要调用"],["get_phys_memory_regions","获取从kernel_end的下一页起，至物理内存最后一页的物理页号"],["handle_kernel_page_fault","处理来自内核的异常中断 当前还没有需要处理的中断"],["new_memory_set_for_task","创建一个新的用户进程对应的内存映射。它的内核态可以访问内核态的所有映射，但不能修改"]],"mod":[["addr","与地址映射相关的函数定义"],["allocator","各种分配器"],["areas","地址段定义"],["page_table","页表实现"],["user","用户地址空间中的指针、数组、数据等"],["vmm","虚拟地址段映射管理"]],"struct":[["FdAllocator",""],["Frame","页帧定义，自动用 new 和 Drop 包装了页帧的分配和回收过程"],["MemorySet","内存段和相关的页表"],["PTEFlags","页表项各位的定义。目前对应 riscv64 的 Sv39 模式"],["PageTable","page table structure"],["PageTableEntry","页表项本体"],["PmAreaFixed","直接分配的物理地址段"],["PmAreaLazy","lazy 分配的物理地址段。当 page fault 发生时会由 VmArea 负责调用这段 PmAreaLazy 进行实际分配"],["Tid","保存一个 TID ，当 Drop 时会自动释放"],["UserPtr","指向用户空间的指针。"],["UserPtrUnchecked","指向用户空间的裸指针"],["VmArea","一段访问权限相同的虚拟地址"]],"trait":[["PmArea","一段访问权限相同的物理地址。注意物理地址本身不一定连续，只是拥有对应长度的空间"]]});