# 2022/04/23 交流

简单来说，就是这周还是在折腾地址空间相关的事

- 重写了页表，之前的页表依赖于 `crate::riscv` 的 riscv::paging::Rv39PageTable
- - 上周贾越凯学长说关于这个riscv::paging的问题的解决方法就是最好不要用它，但那之后只是就着从aCore移过来的代码搞了个能work的版本。现在把这部分代码全部换掉了。

- 修复了sys_write时内核没法访问用户地址的问题，查ISA manual发现是sstatus有一位SUM，设1后就可以了
- - manual不建议常开这个，所以现在是syscall函数进去的时候打开，出来再关上

- 增加了以 `ELF` 格式读用户代码的模块

- 一点点对板子的支持：页表项创建时加上 Access/Dirty 位，因为板子的 Manual 说它不会自动设置。如果OS不设这两位的话硬件会直接发 Page Fault

- 修改了用户启动地址/用户/内核栈等一些设定，统一到2MB，把内核栈从rodata段里抠出来了
- - 主要是为了之后的一个idea：在当前内核/用户共用页表的实现下，启动时每个进程都需要映射一遍全部内核空间的页表，即[kernel_start, physcal_memory_end]。但 U740 的内存比较大，相比之下 K210 只有 8M，所以这个时间开销不太能忽略。类似 rCore 的实现中用户的页表很少，只有它自己linker的一些段。如果能把单个进程的用户侧页表限制在几个二级页表项内，那么就可以只记录这几个子表，每次切换进程时只换表里的几个表项，就不用为每个进程完整生成内核侧的页表。
